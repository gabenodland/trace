import { useEffect, useRef, forwardRef, useImperativeHandle, useCallback } from "react";
import { View, StyleSheet } from "react-native";
import type { WebViewMessageEvent } from "react-native-webview";
import {
  RichText,
  useEditorBridge,
  TenTapStartKit,
  CoreBridge,
} from "@10play/tentap-editor";
import { useTheme } from "../../shared/contexts/ThemeContext";
import {
  splitTitleAndBody,
  combineTitleAndBody,
  getTitleCSS,
  setEditorCallbacks,
  clearEditorCallbacks,
  handleEditorMessage,
} from "./extensions/TitleBridge";

// Import the custom bundled editor HTML (generated by npm run editor:build)
// eslint-disable-next-line @typescript-eslint/no-var-requires
let editorHtml: string = '';
try {
  editorHtml = require("../../../editor-web/build/editorHtml.js").editorHtml || '';
} catch (e) {
  console.error('[RichTextEditor] Custom bundle not found. Run: npm run editor:build');
}

// Debug logging - set to true for development debugging
const DEBUG_EDITOR = false;
const log = (msg: string, data?: any) => {
  if (DEBUG_EDITOR) {
    console.log(`[RichTextEditor] ${msg}`, data ? JSON.stringify(data) : '');
  }
};

/**
 * Remove inline color styles from HTML to ensure theme colors are used
 */
function sanitizeHtmlColors(html: string): string {
  return html.replace(
    /style="([^"]*)"/gi,
    (_, styleContent) => {
      const cleanedStyle = styleContent
        .replace(/\bcolor\s*:\s*[^;]+;?/gi, '')
        .replace(/background-color\s*:\s*[^;]+;?/gi, '')
        .replace(/background\s*:\s*[^;]+;?/gi, '')
        .trim();
      if (!cleanedStyle) return '';
      return `style="${cleanedStyle}"`;
    }
  );
}

interface RichTextEditorProps {
  value: string;
  onChange: (html: string) => void;
  placeholder?: string;
  editable?: boolean;
  onPress?: (tapCoordinates?: { x: number; y: number }) => void;
  onReady?: (content: string) => void;
  title?: string;
  onTitleChange?: (title: string) => void;
  titlePlaceholder?: string;
}

export const RichTextEditor = forwardRef(({
  value,
  onChange,
  placeholder = "Start typing...",
  editable = true,
  onPress,
  onReady,
  title = "",
  onTitleChange,
  titlePlaceholder = "Title",
}: RichTextEditorProps, ref) => {
  const theme = useTheme();

  // Refs for state tracking
  const isLocalChange = useRef(false);
  const lastContent = useRef<string | null>(null);
  const hasCalledOnReady = useRef(false);
  const containerRef = useRef<View>(null);
  const prevEditable = useRef(editable);
  const pendingFocusRequest = useRef(false);
  const lastTitle = useRef<string>(title);
  const isLocalTitleChange = useRef(false);
  const lastSentBody = useRef<string>('');

  // Store callbacks in refs to avoid effect re-runs when parent re-renders
  const callbacksRef = useRef({ onChange, onTitleChange, onReady, onPress });
  callbacksRef.current = { onChange, onTitleChange, onReady, onPress };

  // Title CSS for custom bundle
  const titleCSS = getTitleCSS(titlePlaceholder, {
    text: theme.colors.text.primary,
    disabled: theme.colors.text.disabled,
    border: theme.colors.border.light,
  });

  // Dynamic CSS with theme colors
  const customCSS = `
    @import url('${theme.typography.webFontUrl}');
    * {
      line-height: 1.4 !important;
      font-family: ${theme.typography.webFontFamily} !important;
    }
    body {
      background-color: ${theme.colors.background.primary} !important;
      color: ${theme.colors.text.primary} !important;
      font-family: ${theme.typography.webFontFamily} !important;
    }
    p {
      margin: 0 !important;
      padding: 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    p + p {
      margin-top: 4px !important;
    }
    h1 {
      font-size: 24px !important;
      font-weight: bold !important;
      margin: 8px 0 4px 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    h2 {
      font-size: 20px !important;
      font-weight: bold !important;
      margin: 6px 0 4px 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    ul, ol {
      padding-left: 24px !important;
      margin-top: 4px !important;
      margin-bottom: 4px !important;
      color: ${theme.colors.text.primary} !important;
    }
    ul:not([data-type="taskList"]) ul:not([data-type="taskList"]),
    ol ul:not([data-type="taskList"]),
    ul:not([data-type="taskList"]) ol,
    ol ol {
      padding-left: 20px !important;
    }
    ol { list-style-type: decimal !important; }
    ol ol { list-style-type: lower-alpha !important; }
    ol ol ol { list-style-type: lower-roman !important; }
    ol ol ol ol { list-style-type: upper-alpha !important; }
    ol ol ol ol ol { list-style-type: upper-roman !important; }
    ul[data-type="taskList"] {
      padding-left: 0 !important;
      margin-left: 0 !important;
      list-style: none !important;
    }
    ul[data-type="taskList"] li {
      display: flex !important;
      align-items: flex-start !important;
    }
    ul[data-type="taskList"] li > label {
      margin-right: 8px !important;
      user-select: none !important;
    }
    ul[data-type="taskList"] ul[data-type="taskList"],
    li[data-type="taskItem"] ul[data-type="taskList"] {
      padding-left: 20px !important;
      margin-left: 0 !important;
    }
    .ProseMirror {
      -webkit-text-size-adjust: 100%;
      background-color: ${theme.colors.background.primary} !important;
      color: ${theme.colors.text.primary} !important;
    }
    .ProseMirror > *:first-child {
      margin-top: 10px !important;
    }
    .ProseMirror::before {
      content: "";
      display: block;
      height: 10px;
    }
    .ProseMirror p.is-editor-empty:first-child::before {
      color: ${theme.colors.text.disabled} !important;
    }
    a {
      color: ${theme.colors.functional.accent} !important;
    }
    ${titleCSS}
  `;

  // Build initial content with title
  const buildInitialContent = () => {
    const sanitizedBody = sanitizeHtmlColors(value);
    return combineTitleAndBody(title, sanitizedBody);
  };

  // Editor configuration - always use custom bundle
  // Replace CoreBridge in TenTapStartKit with CSS-configured version (avoid duplicate)
  const bridgeExtensions = TenTapStartKit.map(bridge =>
    bridge === CoreBridge ? CoreBridge.configureCSS(customCSS) : bridge
  );
  const editor = useEditorBridge({
    autofocus: false,
    avoidIosKeyboard: true,
    initialContent: buildInitialContent(),
    editable: true,
    bridgeExtensions,
    customSource: editorHtml,
  });

  // Set up callbacks for receiving events from custom bundle
  // Use refs for callbacks to avoid re-running effect on every parent render
  // NOTE: onTitleChange removed - TitleBridge was removed from web bundle to eliminate
  // duplicate title notifications. Title is now extracted from ContentUpdate HTML only.
  useEffect(() => {
    setEditorCallbacks({
      onFocusChange: (focused: boolean) => {
        const { onPress } = callbacksRef.current;
        if (focused && !editable && onPress) {
          log('Editor focused while in read-only UI mode');
          pendingFocusRequest.current = true;
          onPress();
        }
      },
      onContentChange: (html: string) => {
        const { onChange, onTitleChange, onReady } = callbacksRef.current;
        log('onContentChange received', { htmlLen: html?.length });
        if (!html) return;

        // First content - editor is ready
        if (lastContent.current === null) {
          log('First content (editor ready)', { htmlLen: html.length });
          lastContent.current = html;

          if (!hasCalledOnReady.current && onReady) {
            hasCalledOnReady.current = true;
            const { body } = splitTitleAndBody(html);
            log('Calling onReady', { bodyLen: body.length });
            onReady(body);
          }
          return;
        }

        // Content changed
        if (html !== lastContent.current) {
          lastContent.current = html;
          isLocalChange.current = true;

          const { title: extractedTitle, body } = splitTitleAndBody(html);
          log('Content changed', { title: extractedTitle, bodyLen: body.length });

          // Notify title change
          if (extractedTitle !== lastTitle.current && onTitleChange) {
            lastTitle.current = extractedTitle;
            isLocalTitleChange.current = true;
            onTitleChange(extractedTitle);
          }

          // Notify body change
          lastSentBody.current = body;
          onChange(body);
        }
      },
    });

    return () => clearEditorCallbacks();
  }, [editable]); // Only re-run when editable changes, not on every callback change

  // Handle WebView messages from custom bundle
  const onEditorMessage = useCallback((event: WebViewMessageEvent) => {
    try {
      handleEditorMessage(event.nativeEvent.data);
    } catch {
      // Not our message
    }
  }, []);

  // Send command to custom bundle
  const sendCommand = useCallback((type: string, payload?: any) => {
    try {
      const webview = (editor as any).webviewRef?.current;
      if (webview && typeof webview.injectJavaScript === 'function') {
        const payloadStr = payload ? JSON.stringify(payload) : 'undefined';
        webview.injectJavaScript(`window.editorCommand&&window.editorCommand('${type}',${payloadStr});true;`);
        return true;
      }
    } catch (e) {
      log('sendCommand error', { type, error: e });
    }
    return false;
  }, [editor]);

  useImperativeHandle(ref, () => ({
    // Formatting commands
    toggleBold: () => sendCommand('toggleBold'),
    toggleItalic: () => sendCommand('toggleItalic'),
    toggleUnderline: () => sendCommand('toggleUnderline'),
    toggleBulletList: () => sendCommand('toggleBulletList'),
    toggleOrderedList: () => sendCommand('toggleOrderedList'),
    toggleTaskList: () => sendCommand('toggleTaskList'),
    setHeading: (level: 1 | 2 | 3 | 4 | 5 | 6) => sendCommand('setHeading', { level }),
    indent: () => sendCommand('indent'),
    outdent: () => sendCommand('outdent'),
    blur: () => sendCommand('blur'),
    focus: () => editor.focus(),
    getHTML: () => editor.getHTML(),
    setContent: (html: string) => editor.setContent(html),

    // Focus state management
    clearPendingFocus: () => { pendingFocusRequest.current = false; },
    requestFocusSync: () => {
      const webview = (editor as any).webviewRef?.current;
      if (webview) {
        webview.requestFocus();
        editor.focus('end');
      }
    },
    markPendingFocus: () => { pendingFocusRequest.current = true; },
    scrollToCursor: () => { sendCommand('scrollToCursor'); editor.focus(); },

    // Title methods
    focusTitle: () => { log('focusTitle'); sendCommand('focusTitle'); },
    focusBody: () => sendCommand('focusBody'),
  }), [editor, sendCommand]);

  // Update editor when external title changes
  useEffect(() => {
    if (isLocalTitleChange.current) {
      isLocalTitleChange.current = false;
      return;
    }

    if (title !== lastTitle.current) {
      lastTitle.current = title;
      const currentHtml = lastContent.current || '';
      const { body } = splitTitleAndBody(currentHtml);
      const newHtml = combineTitleAndBody(title, body);

      if (newHtml !== currentHtml) {
        log('External title change, updating editor');
        editor.setContent(newHtml);
        lastContent.current = newHtml;
      }
    }
  }, [title, editor]);

  // Update editor when value (body) changes externally
  useEffect(() => {
    if (isLocalChange.current) {
      isLocalChange.current = false;
      return;
    }

    const sanitizedValue = value ? sanitizeHtmlColors(value) : value;

    // Skip echo-back of our own change
    if (sanitizedValue === lastSentBody.current) {
      log('Skipping echo-back');
      return;
    }

    const targetContent = combineTitleAndBody(lastTitle.current, sanitizedValue);
    const currentBody = splitTitleAndBody(lastContent.current || '').body;

    if (sanitizedValue !== currentBody) {
      log('External body change', { newLen: sanitizedValue?.length, oldLen: currentBody?.length });

      const trySetContent = async (attempt: number) => {
        try {
          editor.setContent(targetContent);
          const actualContent = await editor.getHTML();
          lastContent.current = actualContent;
          log('setContent succeeded', { attempt });
        } catch (e) {
          if (attempt < 10) {
            setTimeout(() => trySetContent(attempt + 1), Math.min(100 * (attempt + 1), 500));
          } else {
            console.warn('[RichTextEditor] Failed to set content after 10 attempts');
          }
        }
      };

      trySetContent(0);
    }
  }, [value, editor]);

  // Handle editable state transitions
  useEffect(() => {
    log('editable change', { prev: prevEditable.current, now: editable, pending: pendingFocusRequest.current });

    if (!prevEditable.current && editable && pendingFocusRequest.current) {
      pendingFocusRequest.current = false;
      log('Edit mode activated, editor already focused');
    } else if (prevEditable.current && !editable) {
      log('Became read-only, blurring');
      editor.blur();
    }

    prevEditable.current = editable;
  }, [editable, editor]);

  return (
    <View ref={containerRef} style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
      <RichText
        editor={editor}
        showsVerticalScrollIndicator={true}
        overScrollMode="never"
        style={{ flex: 1, backgroundColor: theme.colors.background.primary }}
        onMessage={onEditorMessage}
      />
    </View>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
