import { useEffect, useRef, forwardRef, useImperativeHandle, useMemo } from "react";
import { View, StyleSheet } from "react-native";
import {
  RichText,
  useEditorBridge,
  TenTapStartKit,
  CoreBridge,
} from "@10play/tentap-editor";
import { useTheme } from "../../shared/contexts/ThemeContext";
import { createScopedLogger } from "../../shared/utils/logger";

// Custom editor bundle with title-first schema
// Generated by: npm run editor:build (uses JSON.stringify for proper escaping)
// @ts-ignore - JS file with .d.ts declaration
import { editorHtml } from "../../../editor-web/build/editorHtml.js";

// Scoped logger for editor - debug logs only show in dev or when debug mode enabled
const log = createScopedLogger('RichTextEditor', 'ðŸ“');

/**
 * Remove inline color styles from HTML to ensure theme colors are used
 * This handles pasted content that may have hardcoded colors like "color: rgb(0, 0, 0)"
 */
function sanitizeHtmlColors(html: string): string {
  return html.replace(
    /style="([^"]*)"/gi,
    (match, styleContent) => {
      // Remove color and background-color properties from the style
      const cleanedStyle = styleContent
        .replace(/\bcolor\s*:\s*[^;]+;?/gi, '')
        .replace(/background-color\s*:\s*[^;]+;?/gi, '')
        .replace(/background\s*:\s*[^;]+;?/gi, '')
        .trim();

      // If style is now empty, remove the attribute entirely
      if (!cleanedStyle) {
        return '';
      }
      return `style="${cleanedStyle}"`;
    }
  );
}

interface RichTextEditorProps {
  value: string;
  onChange: (html: string) => void;
  placeholder?: string;
  editable?: boolean;
  onDoublePress?: () => void;
  onPress?: (tapCoordinates?: { x: number; y: number }) => void;
  /** Called once when editor is ready with its actual (possibly normalized) content */
  onReady?: (content: string) => void;
}

export const RichTextEditor = forwardRef(({
  value,
  onChange,
  placeholder = "Start typing...",
  editable = true,
  onDoublePress,
  onPress,
  onReady,
}: RichTextEditorProps, ref) => {
  const theme = useTheme();
  const isLocalChange = useRef(false);
  // Track when last local change occurred - used to distinguish local vs external updates
  // External updates (sync) happen seconds/minutes apart; local re-renders are milliseconds apart
  const lastLocalChangeTime = useRef<number>(0);
  // Initialize to null - first poll will sync to editor's normalized content
  const lastContent = useRef<string | null>(null);
  const hasCalledOnReady = useRef(false);
  // Track if editor is ready (first successful getHTML completed)
  const isEditorReady = useRef(false);
  const containerRef = useRef<View>(null);
  const prevEditable = useRef(editable);
  // Track if focus was requested during read-only mode (before editable transition)
  const pendingFocusRequest = useRef(false);
  // Track pending content that needs to be set once editor is ready
  const pendingContent = useRef<string | null>(null);
  // Capture initial value only once - prevents editor recreation on every keystroke
  const initialValueRef = useRef<string>(sanitizeHtmlColors(value) || '');

  // Dynamic CSS with theme colors and fonts - memoized to prevent editor recreation
  const customCSS = useMemo(() => `
    @import url('${theme.typography.webFontUrl}');
    * {
      line-height: 1.4 !important;
      font-family: ${theme.typography.webFontFamily} !important;
    }
    body {
      background-color: ${theme.colors.background.primary} !important;
      color: ${theme.colors.text.primary} !important;
      font-family: ${theme.typography.webFontFamily} !important;
      margin: 0 !important;
      padding: 0 !important;
    }
    p {
      margin: 0 !important;
      padding: 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    p + p {
      margin-top: 4px !important;
    }
    h1 {
      font-size: 24px !important;
      font-weight: bold !important;
      margin: 8px 0 4px 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    /* Title (entry-title) specific styling */
    h1.entry-title {
      margin: 12px 0 12px 0 !important;
      padding: 0 0 8px 0 !important;
      border-bottom: 1px solid ${theme.colors.border.light} !important;
      min-height: 1.4em !important;
    }
    /* Title placeholder */
    h1.entry-title.is-empty::before {
      content: attr(data-placeholder) !important;
      color: ${theme.colors.text.disabled} !important;
      pointer-events: none;
      position: absolute;
    }
    h2 {
      font-size: 20px !important;
      font-weight: bold !important;
      margin: 6px 0 4px 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    ul, ol {
      padding-left: 20px !important;
      margin: 4px 0 !important;
      color: ${theme.colors.text.primary} !important;
    }
    /* Nested regular lists - exclude task lists */
    ul:not([data-type="taskList"]) ul:not([data-type="taskList"]),
    ol ul:not([data-type="taskList"]),
    ul:not([data-type="taskList"]) ol,
    ol ol {
      padding-left: 20px !important;
    }
    /* Numbered list hierarchy: 1 -> a -> i -> A -> I (5 levels) */
    ol {
      list-style-type: decimal !important;
    }
    ol ol {
      list-style-type: lower-alpha !important;
    }
    ol ol ol {
      list-style-type: lower-roman !important;
    }
    ol ol ol ol {
      list-style-type: upper-alpha !important;
    }
    ol ol ol ol ol {
      list-style-type: upper-roman !important;
    }
    /* Task list (checkbox) styling */
    ul[data-type="taskList"] {
      padding-left: 0 !important;
      margin-left: 0 !important;
      list-style: none !important;
    }
    ul[data-type="taskList"] li {
      display: flex !important;
      align-items: flex-start !important;
    }
    ul[data-type="taskList"] li > label {
      margin-right: 8px !important;
      user-select: none !important;
    }
    /* Nested task lists - use same indent as regular bullet nested lists */
    ul[data-type="taskList"] ul[data-type="taskList"],
    li[data-type="taskItem"] ul[data-type="taskList"] {
      padding-left: 20px !important;
      margin-left: 0 !important;
    }
    .ProseMirror {
      -webkit-text-size-adjust: 100%;
      background-color: ${theme.colors.background.primary} !important;
      color: ${theme.colors.text.primary} !important;
      padding: 0 !important;
      /* Small padding after content - scroll-margin-bottom handles cursor positioning */
      padding-bottom: 120px !important;
      margin: 0 !important;
      /* No min-height - let content determine height to prevent over-scrolling */
    }
    /* Scroll margin ensures scrollIntoView leaves clearance below cursor.
       This positions the cursor line higher on screen, not at the edge. */
    .ProseMirror p,
    .ProseMirror h1,
    .ProseMirror h2,
    .ProseMirror li,
    .ProseMirror ul,
    .ProseMirror ol {
      scroll-margin-bottom: 120px !important;
    }
    /* Placeholder styling for body content
       Only show placeholder when the paragraph immediately after title is empty
       AND there's no other content (it's the last child).
       This prevents placeholder showing on empty first-p when there's text after */
    .ProseMirror > h1.entry-title + p.is-empty:last-child::before,
    .ProseMirror > p.is-editor-empty:first-child:last-child::before {
      color: ${theme.colors.text.disabled} !important;
    }
    /* Hide placeholder on empty paragraphs that have content after them */
    .ProseMirror > h1.entry-title + p.is-empty:not(:last-child)::before {
      display: none !important;
    }
    /* Link styling */
    a {
      color: ${theme.colors.functional.accent} !important;
    }
  `, [theme]);

  // Filter out placeholder bridge - our custom bundle handles placeholders
  // Memoized to prevent editor recreation
  const bridgesWithoutPlaceholder = useMemo(() =>
    TenTapStartKit.filter((bridge: any) => {
      const name = bridge?.name || bridge?.tiptapExtension?.name || '';
      return !name.toLowerCase().includes('placeholder');
    }),
  []);

  // Memoize bridge extensions to prevent editor recreation
  const bridgeExtensions = useMemo(() => [
    ...bridgesWithoutPlaceholder,
    CoreBridge.configureCSS(customCSS),
  ], [bridgesWithoutPlaceholder, customCSS]);

  // Editor is always editable internally - we control interaction via overlay
  // NOTE: useEditorBridge returns new wrapper objects on every render, but the
  // underlying WebView is stable. This is library behavior, not a real recreation.
  const editorOptions = useMemo(() => ({
    autofocus: false,
    avoidIosKeyboard: true,
    initialContent: initialValueRef.current,
    editable: true,
    customSource: editorHtml,
    bridgeExtensions,
  }), [bridgeExtensions]);

  const editor = useEditorBridge(editorOptions);

  useImperativeHandle(ref, () => ({
    toggleBold: () => editor.toggleBold(),
    toggleItalic: () => editor.toggleItalic(),
    toggleUnderline: () => editor.toggleUnderline(),
    toggleBulletList: () => editor.toggleBulletList(),
    toggleOrderedList: () => editor.toggleOrderedList(),
    toggleTaskList: () => editor.toggleTaskList(),
    setHeading: (level: 1 | 2 | 3 | 4 | 5 | 6) => editor.toggleHeading(level),
    toggleHeading: (level: 1 | 2 | 3 | 4 | 5 | 6) => editor.toggleHeading(level),
    indent: () => {
      // Simulate Tab key press for better task list support
      try {
        const webview = (editor as any).webviewRef?.current;
        if (webview && typeof webview.injectJavaScript === 'function') {
          webview.injectJavaScript(`
            (function() {
              const event = new KeyboardEvent('keydown', {
                key: 'Tab',
                code: 'Tab',
                keyCode: 9,
                which: 9,
                bubbles: true,
                cancelable: true
              });
              document.activeElement?.dispatchEvent(event);
            })();
            true;
          `);
        }
      } catch (e) {
        // Fallback to sink
        editor.sink();
      }
    },
    outdent: () => {
      // Simulate Shift+Tab key press for better task list support
      try {
        const webview = (editor as any).webviewRef?.current;
        if (webview && typeof webview.injectJavaScript === 'function') {
          webview.injectJavaScript(`
            (function() {
              const event = new KeyboardEvent('keydown', {
                key: 'Tab',
                code: 'Tab',
                keyCode: 9,
                which: 9,
                shiftKey: true,
                bubbles: true,
                cancelable: true
              });
              document.activeElement?.dispatchEvent(event);
            })();
            true;
          `);
        }
      } catch (e) {
        // Fallback to lift
        editor.lift();
      }
    },
    blur: () => editor.blur(),
    focus: () => editor.focus(),
    getHTML: () => editor.getHTML(),
    setContent: (html: string) => editor.setContent(html),
    // Clear any pending focus request (use when title gets focus instead)
    clearPendingFocus: () => {
      log.debug('clearPendingFocus called');
      pendingFocusRequest.current = false;
    },
    // Request focus synchronously - must be called in user gesture context
    // This triggers the native WebView requestFocus which shows the keyboard
    requestFocusSync: () => {
      log.debug('requestFocusSync called');
      const webview = (editor as any).webviewRef?.current;
      if (webview) {
        // Call requestFocus synchronously to show keyboard (iOS requirement)
        webview.requestFocus();
        // Then focus the editor content
        editor.focus('end');
      }
    },
    // Mark that focus should happen when editable becomes true
    markPendingFocus: () => {
      log.debug('markPendingFocus called');
      pendingFocusRequest.current = true;
    },
    // Force scroll to cursor position
    scrollToCursor: () => {
      // Call focus first - this triggers tentap's built-in scroll handling
      editor.focus();

      // Also inject JavaScript as backup - use 'nearest' to only scroll if needed
      try {
        const webview = (editor as any).webviewRef?.current;
        if (webview && typeof webview.injectJavaScript === 'function') {
          webview.injectJavaScript(`
            (function() {
              const selection = window.getSelection();
              if (!selection || selection.rangeCount === 0) return;

              const range = selection.getRangeAt(0);
              const element = range.startContainer.nodeType === 3
                ? range.startContainer.parentElement
                : range.startContainer;

              if (element && element.scrollIntoView) {
                // Use 'nearest' to only scroll if cursor is outside visible area.
                // This prevents jarring jumps when cursor is already visible.
                element.scrollIntoView({ behavior: 'auto', block: 'nearest' });
              }

              // Also try ProseMirror scrollIntoView which handles keyboard awareness
              if (window.editor?.view) {
                window.editor.view.dispatch(
                  window.editor.view.state.tr.scrollIntoView()
                );
              }
            })();
            true;
          `);
        }
      } catch (e) {
        // Silently fail
      }
    },
  }));

  useEffect(() => {
    // Subscribe to content changes with debouncing
    const interval = setInterval(async () => {
      const html = await editor.getHTML();
      if (lastContent.current === null) {
        // First poll - editor is ready with its (possibly normalized) content
        lastContent.current = html;
        isEditorReady.current = true;
        log.debug('Editor is now ready');
        if (!hasCalledOnReady.current && onReady) {
          hasCalledOnReady.current = true;
          onReady(html);
        }
        return;
      }
      if (html !== lastContent.current) {
        lastContent.current = html;
        isLocalChange.current = true;
        lastLocalChangeTime.current = Date.now();
        onChange(html);
      }
    }, 300); // Poll every 300ms

    return () => {
      clearInterval(interval);
    };
  }, [editor, onChange, onReady]);

  // Update editor when value changes externally (not from typing)
  // Uses retry logic to handle race condition when editor isn't ready yet
  useEffect(() => {
    // Sanitize incoming value to remove inline color styles
    const sanitizedValue = value ? sanitizeHtmlColors(value) : value;

    // Skip if this is a local change (from polling interval)
    if (isLocalChange.current) {
      isLocalChange.current = false;
      return;
    }

    // Skip if value hasn't changed
    if (!sanitizedValue || sanitizedValue === lastContent.current) {
      return;
    }

    // Check if this is likely a re-render from local typing (within 500ms of last local change)
    // True external updates (sync from another device) happen seconds/minutes apart
    // If lastLocalChangeTime is 0, no local change has occurred yet - treat as external
    const timeSinceLocalChange = lastLocalChangeTime.current > 0
      ? Date.now() - lastLocalChangeTime.current
      : Infinity;
    const isLikelyLocalRerender = timeSinceLocalChange < 500;

    if (isLikelyLocalRerender) {
      // This is probably a re-render caused by local typing propagating through state
      // Update lastContent to match but don't call setContent (editor already has it)
      log.debug('Skipping external update - likely local re-render', { timeSinceLocalChange });
      lastContent.current = sanitizedValue;
      return;
    }

    // This is a true external update (sync, initial load, conflict resolution)
    log.info('External content update', {
      timeSinceLocalChange,
      valueLength: sanitizedValue?.length,
      lastContentLength: lastContent.current?.length,
      isEditorReady: isEditorReady.current,
    });

    // Store the pending content - will be set by polling when editor is ready
    pendingContent.current = sanitizedValue;

    // If editor is not ready yet, don't try to set content - let polling handle it
    if (!isEditorReady.current) {
      log.debug('Editor not ready, content queued for when ready');
      return;
    }

    // Editor is ready - set content immediately
    (async () => {
      try {
        editor.setContent(sanitizedValue);
        const actualContent = await editor.getHTML();
        lastContent.current = actualContent;
        pendingContent.current = null;
        if (editable) {
          editor.focus('start');
        }
        log.debug('setContent succeeded immediately', { sentLength: sanitizedValue.length, actualLength: actualContent.length });
      } catch (e) {
        // Failed even though editor was "ready" - leave in pendingContent for polling to retry
        log.debug('setContent failed despite ready state, polling will retry');
      }
    })();
  }, [value, editor, editable]);

  // Retry pending content when editor might be ready (check every 200ms)
  // Retry pending content once editor is ready
  // This handles the case where value prop changes before editor is initialized
  useEffect(() => {
    const interval = setInterval(async () => {
      // Only try if we have pending content AND editor is ready
      if (pendingContent.current !== null && isEditorReady.current) {
        try {
          const contentToSet = pendingContent.current;
          editor.setContent(contentToSet);
          const actualContent = await editor.getHTML();
          lastContent.current = actualContent;
          pendingContent.current = null;
          log.debug('Pending content applied', { sentLength: contentToSet.length, actualLength: actualContent.length });
          if (editable) {
            editor.focus('start');
          }
        } catch (e) {
          log.debug('Pending content apply failed, will retry');
        }
      }
    }, 200);

    return () => clearInterval(interval);
  }, [editor, editable]);

  // Handle transition to editable UI mode
  useEffect(() => {
    const wasEditable = prevEditable.current;

    // Only log on actual transitions to reduce noise
    if (wasEditable !== editable) {
      log.debug('editable transition', {
        from: wasEditable,
        to: editable,
        pendingFocusRequest: pendingFocusRequest.current
      });
    }

    if (!wasEditable && editable) {
      // Just became editable UI mode
      // If pendingFocusRequest is set, the editor already has focus from user tap
      // Don't call editor.focus() - it would move cursor to end
      if (pendingFocusRequest.current) {
        pendingFocusRequest.current = false;
        log.debug('Edit mode activated, editor already focused from tap');
        // Editor already has focus and cursor is at tap position - do nothing
      }
    } else if (wasEditable && !editable) {
      // Just became read-only - blur the editor
      log.debug('Became read-only, blurring');
      editor.blur();
    }

    prevEditable.current = editable;
  }, [editable, editor]);

  // Subscribe to editor focus state changes
  // When user taps editor in read-only UI mode, detect it and enter edit mode
  useEffect(() => {
    // Check if editor focus changed - if focused while in read-only UI mode, trigger onPress
    const checkFocus = () => {
      const state = editor.getEditorState();
      if (state.isFocused && !editable && onPress) {
        log.debug('Editor focused while in read-only UI mode, triggering onPress');
        // Don't blur - let the focus stay so keyboard shows
        // Cursor is already at tap position - just mark that we triggered edit mode
        pendingFocusRequest.current = true;
        onPress();
      }
    };

    // Poll for focus changes (editor state subscription)
    const interval = setInterval(checkFocus, 100);

    return () => clearInterval(interval);
  }, [editable, editor, onPress]);

  return (
    <View ref={containerRef} style={[styles.container, { backgroundColor: theme.colors.background.primary }]}>
      <RichText
        editor={editor}
        showsVerticalScrollIndicator={true}
        overScrollMode="never"
        style={{ backgroundColor: theme.colors.background.primary }}
      />
    </View>
  );
});

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
});
